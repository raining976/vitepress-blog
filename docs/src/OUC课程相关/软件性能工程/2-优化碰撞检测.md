# 实验描述

本实验原项目实现了一个屏保程序，该屏保程序是由若干线段组成的图形，给予每条线段初速度，各个线段之间会相互碰撞，碰撞过程动量能量守恒（线段长度代替质量）。其中对线段的碰撞次数进行了统计，原程序采用的是遍历所有的线段，两两比较是否相交，时间复杂度为$O(N^2)$，此种方式统计碰撞次数过于低效，本实验要求就是在此背景下修改计算碰撞次数的算法，从而提升执行效率。

# 任务要求

测试版要求使用**四叉树**数据结构进行优化。

# 实验过程

<aside>
📝 一些声明：
1. 后文出现的“碰撞”，均指的是在当前时间片经过以后判断这两条线段是否相交的问题，这里的碰撞源码中实际上是判断前后两个时刻所构成的平行四边形是否包裹某条线段，但因为本次测试版不考虑该实现细节，所以这里也就没有区分。
2. 下文所指的碰撞均是当前时间片内发生的碰撞可能，并不是全部时间内

</aside>

## 原理

<aside>
💡 **四叉树**（英语：Quadtree）是一种树状数据结构，在每一个节点上会有四个子区块。四叉树常应用于二维空间资料的分析与分类。

</aside>



用一个比较丑陋的图表示四叉树分割二维平面后的情况，很显然，不在同一片区域的线段都不可能碰撞。当然这是建立在正确处理的基础上，包括其中在边缘的线段。

这里只是说明用四叉树必然可以省略大量的判断，也就是说四叉树本身就已经提前判断了许多不会碰撞的线段。

下面将介绍如何进行四叉树的构造以及如何进行碰撞检测。

## 构造四叉树

- 插入
- 分裂
- 满了怎么办？

### 四叉树的结构

为了后续的碰撞检测，这里必须要加入parent结点供向上查找使用，后面会详细说明。

```c
// quadtree.h
#define QUAD 4
#define MAX_DEPTH 8
#define MAX_LINES 16

typedef struct Quadtree Quadtree;

struct Quadtree {
  Quadtree* parent;   // 父节点

  Quadtree* children; // 四个孩子结点
                      // 布局为:
                      // 0 1 
                      // 3 2

  Line** lines;       // 线数组的指针

  Vec center;         // 当前结点的中间位置
  float width;        // 结点代表的矩阵宽度

  uint16_t num_lines; // lines长度
  uint16_t capacity;  // lines 的容量，上限

  uint8_t depth;      // 结点深度

};

// 初始化四叉树
Quadtree initializeQuadtree(Quadtree* parent, double x, double y, float width, uint8_t depth);

// 创建一个四叉树
Quadtree* createQuadtree(Quadtree* parent, double x, double y ,float width, uint8_t depth);
// 强制内联 避免函数调用带来的开销
static inline void allocateChildren(Quadtree* restrict tree) __attribute__((always_inline));;
static inline void makeSpaceForMoreLine(Quadtree* restrict tree) __attribute__((always_inline));;
void destroyTree(Quadtree* restrict tree);

// 向四叉树中插入线段
void insertLine(Quadtree* restrict tree, Line* restrict line);
uint16_t countLines(Quadtree* restrict tree);

// 判断线段是否在当前结点之内
static inline bool isLineFit(Quadtree* restrict tree, Line* restrict line) __attribute__((always_inline));;

// 结点被线填充后 就开始判断碰撞
static inline void registerCollision(Line* restrict line1, Line* restrict line2, IntersectionEventList* intersectionList) __attribute__((always_inline));;
// 对树里的结点进行碰撞检测
void detectCollision(Quadtree* restrict tree, IntersectionEventList* restrict intersectionList);
```

### 如何判断插入哪个子节点中

我们这里用的是判断当前时刻以及经过一个时间片以后的时刻线段的两次位置都在某个子节点中时，才插入该结点。

对于那些不在四个节点中的线段，那就放入当前tree节点中，也就是说，**并不是所有的线段都存放在叶子结点中，非叶子结点也会存放线段**。

### 插入结点

对于一个即将插入四叉树中的结点：

- 首先判断当前结点有没有子节点，如果有，那么就遍历当前这些子节点，看看能否插入某个子节点，如果能，递归调用插入函数；
- 否则，要么没有子节点，要么就是所有的子节点都无法容纳这个线段，也就是说，这个线段在某些子节点的边界上，此时我们就要考虑当前结点的线段数组是否有位置，如果还有位置，就直接放入即可。
- 如果没有位置，此时就要考虑是扩容，还是对当前结点进行分裂，因为四叉树的深度是有限的，如果达到了最深层，那么接下来的线段都需要存到最深层的结点中，如果结点空间满了，就需要对线段数组扩容。
- 扩容结点的操作下面会详细介绍，这里必须要说明的是，**必须要把当前结点中的线段加入到扩容后的符合条件的子节点中，如果都找不到合适的，就放回原来的结点**。
- 扩容完成后，遍历四个子节点，如果有符合条件的子节点，就插入进去；如果都不符合，说明当前节点在边界上，我们就需要放到当前结点中。

可以看到，对于每个即将插入的线段，我们**第一步要做的事情就是看看该线段应该放到哪个子节点中**

这里参考了一个库文件quadtree.js。

下面贴上插入函数的代码。

```c
// 向四叉树中插入线段
void insertLine(Quadtree *restrict tree, Line *restrict line) {
	// 先看该线段应该放到哪些子节点中 如果有的话
  if (tree->children != NULL) {
    for (uint8_t i = 0; i < QUAD; i++) {
      if (isLineFit(tree->children + i, line)) {
        insertLine(tree->children + i, line);
        return;
      }
    }
  }

  // 还有空间 直接加进去
  if (tree->num_lines < tree->capacity) {
    tree->lines[tree->num_lines++] = line;
    return;
  }

  // 空间爆掉了 并且还没有分裂子节点
  // 那要么就是还没有达到最深 需要创建子结点
  // 要么已经达到最深的结点并且线数组不够大了 需要对当前结点扩容
  if (tree->children == NULL) {
    // 如果当前结点就是最深的结点了 就需要对该结点的线数组进行扩容
    if (tree->depth == MAX_DEPTH && tree->num_lines >= tree->capacity) {
      makeSpaceForMoreLine(tree);
    }
    if (tree->num_lines < tree->capacity) {
      tree->lines[tree->num_lines++] = line;
      return;
    }
    // 如果还没有到达最深的结点 只需要分裂子结点即可
    allocateChildren(tree);
  }

  // 有子节点了 那么就向下查找
  // 看看放到哪里面合适
  if (tree->children != NULL) {
    for (uint8_t i = 0; i < QUAD; i++) {
      if (isLineFit(tree->children + i, line)) {
        insertLine(tree->children + i, line);
        return;
      }
    }
    // 如果找不到一个合适的子节点存入这条线段 我们就放在当前节点中
    // 这说明这条线段是在边缘的
    if (tree->num_lines >= tree->capacity)
      makeSpaceForMoreLine(tree);
    if (tree->num_lines < tree->capacity) {
      tree->lines[tree->num_lines++] = line;
      return;
    }

    // 执行到这行说明出现了问题 应该排查
    assert(0);
  }
}
```

### 分裂节点

在节点的线段数量超过`capacity`阈值的时候，我们就要考虑是否对节点进行分裂，如果没有到达最深的一层，就需要分裂节点，将当前节点代表的空间平均分裂成四份，当然也可以不平分，我们考虑实现最简单的情况。

分裂也就是对四个子节点申请空间，并初始化其中的各项数值，以保证代表的是左上、右上、左下、右下四个小的正方形空间，下面用一张图表示这个分裂过程数值之间的关系。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/80020338-2b1f-4d44-9427-7692daa2b57e/c0ea0fee-6bbc-4675-84cb-d5014a7fa5a0/Untitled.jpeg)

有了四个子节点的参数，我们只需要申请空间初始化即可。

初始化完了该结点的四个子节点，接下来就是将当前结点中已经插入进来的线段分配给其子节点，对于那些都不属于四个子节点中的线段，我们只需要从0开始放回原来的数组中即可。这里为了不额外增加空间开销，就沿用了原来的数组，通过两个指针就可以保证从0开始没有空的情况。

代码实现：

```c
// 强制内联 避免函数调用带来的开销
// 给当前结点创建子节点并将所有的线段转移到子节点中
inline void allocateChildren(Quadtree *restrict tree) {
  if (tree == NULL)
    return;
  tree->children = (Quadtree *)malloc(sizeof(Quadtree) * QUAD);
  float width = tree->width * 0.5;
  float halfwidth = tree->width * 0.25;
  tree->children[0] =
      initializeQuadtree(tree, tree->center.x - halfwidth,
                         tree->center.y + halfwidth, width, tree->depth + 1);
  tree->children[1] =
      initializeQuadtree(tree, tree->center.x + halfwidth,
                         tree->center.y + halfwidth, width, tree->depth + 1);
  tree->children[2] =
      initializeQuadtree(tree, tree->center.x + halfwidth,
                         tree->center.y - halfwidth, width, tree->depth + 1);
  tree->children[3] =
      initializeQuadtree(tree, tree->center.x - halfwidth,
                         tree->center.y - halfwidth, width, tree->depth + 1);

  // 将当前结点的所有线放到四个孩子结点下
  uint16_t num_lines = tree->num_lines;
  tree->num_lines = 0;

  // 这里要分别放入符合条件的子结点 如果都不符合 就放回当前tree结点的线数组中
  for (uint16_t i = 0; i < num_lines; i++) {
    for (uint8_t j = 0; j < QUAD; j++) {
      if (isLineFit(tree->children + j, tree->lines[i])) {
        insertLine(tree->children + j, tree->lines[i]);
        tree->lines[i] = NULL;
        break;
      }
    }
    // 如果都不满足 并且 tree.num_lines < i 这说明i之前有元素已经放入子节点了
    // 可以避免重复操作
    if (tree->num_lines == i && tree->lines[i] != NULL ) {
      tree->num_lines++;
    } else if (tree->num_lines < i && tree->lines[i] != NULL) {
      if (tree->num_lines >= tree->capacity)
        makeSpaceForMoreLine(tree);
      if (tree->num_lines < tree->capacity)
        tree->lines[tree->num_lines++] = tree->lines[i];
      tree->lines[i] = NULL;
    }
  }
}
```

至此，四叉树的构建就可以用上述过程实现，其中忽略了一些关于数组扩容,四叉树初始化、销毁等比较显然的操作。

所有的线段插入到对应的结点中去时，此时树中节点的状态应该为：

- 非叶子结点中存储的都是那些无法正好在子节点中的线段，也就是跨过边界的线段
- 而叶子结点中存储都是正好在当前节点代表的区域内的线段。

**上述描述均是建立在当前时刻以及经过一个时间片之后的时刻的两种情况取与操作。**

接下来我们考虑的就是如何进行碰撞检测，以及检测哪些线段的问题。

## 检测碰撞

- 结点内部的线段（边缘）
- 结点向上查找 与其他边缘检测

上述最后我们将结点按照叶子结点和非叶子结点进行了分类，显然，叶子结点中的结点线段只有可能和自己结点中的线段碰撞。也就是说，**叶子结点中的线段，绝对不和结点之外的任何线段发生碰撞。**

这也是四叉树结构体可以提前判断的情况，是本方法优化的核心所在。

下面是可能发生碰撞的结点情况：

- **叶子结点**内部的线段之间可能碰撞，因此需要遍历检查其中所有的线段。
- **所有结点**与其**所有直系父节点**中的**边缘线段**可能发生碰撞，因此需要将每个结点中的线段与其所有父节点中的线段进行判断。
- 非叶子结点中的边缘上的线段之间可能发生碰撞。其中边缘线段与内部线段在上述第二点已经包括了进去，因此不再赘述。

<aside>
📝 这里所说的直系父结点就是可以通过parent域向上找到的所有节点。

</aside>

将上述所有情况考虑到，就可以检测所有可能发生碰撞的线段，当然这个过程还是相当复杂，仍然有待优化的可能，比如在边缘上的线段也可以被分类，但是由于中心点附近的边缘非常模糊的原因，也对进一步优化带来了很大的阻碍，这里也就不再展开讨论了。

下面给出碰撞检测部分的代码：

```c
// 对树里的结点进行碰撞检测
void detectCollision(Quadtree *restrict tree,
                     IntersectionEventList *restrict intersectionList) {
  assert(tree != NULL);

  Line *l1 = NULL;
  Line *l2 = NULL;

  uint16_t d, i, j;

  // 这里检查的是那些在矩形边缘不知道放在哪里的那些线段
  // 如果没有字结点 那么检查的就是当前结点中的线段的相交情况
  for (i = 0; i < tree->num_lines; i++) {
    l1 = tree->lines[i];
    for (j = i + 1; j < tree->num_lines; j++) {
      l2 = tree->lines[j];
      registerCollision(l1, l2, intersectionList);
    }
  }

  // 检查子结点
  if (tree->children != NULL) {
    for (uint8_t c = 0; c < QUAD; c++) {
      detectCollision(tree->children + c, intersectionList);
    }
  }

  // 向上查找
  // 判断当前结点中的线段与其所有的父节点中的线段是否有碰撞的可能
  // 也就是检查结点边缘的线段与内部结点线段是否能相交
  Quadtree *parent = tree;
  for (d = 0; d < tree->depth; d++) {
    parent = parent->parent;
    if (parent == NULL)
      return;
    for (i = 0; i < tree->num_lines; i++) {
      l1 = tree->lines[i];
      for (j = 0; j < parent->num_lines; j++) {
        l2 = parent->lines[j];
        registerCollision(l1, l2, intersectionList);
      }
    }
  }
}
```

<aside>
‼️ 值得注意的是，这里registerCollision就是进行调用insecter函数的封装，在执行insecter之前，要确保传入的l1,l2的id是l1更靠前的关系，否则将影响后续碰撞结点链表的排序问题。

</aside>

### 其他说明

- 为了更好的统计碰撞次数，在碰撞结点链表中添加了size的成员变量，可以更快统计碰撞次数。
- 由于源码中的坐标是使用的转换后的坐标，因此在初始化根节点时要考虑使用box坐标，这里的box的边界为`[0.5,1)` ，因此初始中心坐标为`(0.5*(BOX_XMIN+BOX_XMAX), 0.5*(BOX_YMIN+BOX_YMAX))` ,宽度为`BOX_XMAX-BOX_XMIN`



### 性能提升检验

## 优化后的性能表现

<aside>
📝 结点最大容量为32（r==32），最大深度为8的情况

</aside>

<aside>
‼️ **为了提升阅读体验，将优化后的运行截图放到了本文的最后。**

</aside>

### 1000次迭代的情况

| **输入文件** | **执行时间（未优化）** | **执行时间（优化后）** | **线-墙碰撞次数** | **线-线碰撞次数** | **性能提升倍数** |
| --- | --- | --- | --- | --- | --- |
| **mit.in** | 10.43530 s | 3.025782 s | 170 | 2097 | **3.5** |
| **beaver.in** | 1.594542 s | 0.376237 s | 7 | 758 | **4.2** |
| **box.in** | 2.400115 s | 0.726586s | 1379 | 36965 | **3.3** |
| **apple.in_old** | 4.319744 s | 3.406659s | 655 | 18718 | **1.3** |
| **sin_wave.in** | 18.564519 s | 1.832190s | 504 | 280083 | **10** |
| **koch.in** | 254.86879s | 4.874691s | 1088 | 5256 | **133** |
| **apple.in_new** | 4.516861s | 3.446063s | 631 | 19729 | **1.3** |
| **explosion.in** | 5.443508s | 1.763039s | 206 | 16837 | **3** |
| **smalllines.in** | 4.489867s | 1.461990s | 5837 | 77802 | **3** |

### 4000次迭代情况

| **输入文件** | **执行时间（未优化）** | **执行时间（优化后）** | **线-墙碰撞次数** | **线-线碰撞次数** | **性能提升倍数** |
| --- | --- | --- | --- | --- | --- |
| **mit.in** | 39.266656s | 8.113286s | 1262 | 19806 | **4.8** |
| **beaver.in** | 5.542460s | 1.098662s | 219 | 1798 | **5** |
| **box.in** | 10.233927s | 2.740106s | 6239 | 101037 | **3.7** |
| **apple.in_old** | 18.572576s | 12.43560s | 3116 | 103117 | **1.5** |
| **sin_wave.in** | 77.297147s | 7.171883s | 1777 | 480244 | **10.8** |
| **koch.in** | 1030.7703s | 18.76305s | 9718 | 37592 | **55** |
| **apple.in_new** | 19.098123s | 11.93500s | 2877 | 100951 | **1.6** |
| **explosion.in** | 21.930666s | 5.237843s | 1310 | 42918 | **4.2** |
| **smalllines.in** | 18.320586s | 6.371052s | 23895 | 338592 | **2.9** |

### 总结

实验结果很明显看出来，使用四叉树带来的性能提升是非常明显的，而且通过对不同样例的对比分析，可以看到某些样例的性能提升会远远超过其他样例，而有些样例的性能提升不明显，甚至不到两倍，使用-g参数可以清楚的看到，性能提升不明显的那些样例是由于线段聚集度很高，导致某层结点线段数组存了大量的线段(比如apple.in)，导致在与其他线段做比较时花费了大量时间，而那些性能提升非常明显的样例，是因为线段在短时间内就平均分散了(比如koch.in)，而我们容易发现，越是分散分布的线段，使用四叉树分析效率就更高，因为四叉树可以提前排出大量的相距很远并且没有直接父系关系的结点，这为性能提升提供了巨大的帮助。

## 考虑r对性能优化的影响

r在这里指的是每个结点初始时线段数组的大小。

显然如果要想性能发挥到最大，r需要综合考量，但由于我们设定了对于边缘的点加入到当前结点的数组，以及超过容量就扩容的情况，导致即使设定很小的r，最终也会因为扩容达到一个很大的容量，无非扩容会影响性能开销。因此r过小的时候性能也会降低。

r很大的时，此种情况树的深度并没有发挥关键作用，又因为我们需要对每个结点内部进行遍历，因此时间复杂度也会一定程度的增大。

综合考量来看，理想的情况应该是：在树的深度不是很大的情况，每个叶子结点都接近我们设定的r值。

显然达成这个是不现实的，因为屏保程序中的线段是时刻运动的，很难达到“平均分布”的这种状态，也就导致必然会有树的深度达到上限并且扩容大量数组的情况。因此只是简单分析基本情况。

# 并行优化部分

------

并行化的优化主要涉及到了`clik_spawn`和`cilk_for`两个api的使用，以及在并行过程对可能存在的**竞态条件**的处理。

这些优化主要是基于测试部分四叉树中的一些过程的并行化。

## 并行化四叉树的销毁

我们注意到四叉树的销毁需要递归销毁每一个树节点，因此这里递归时将函数调用改为函数生成就可以了。

```c
// 销毁树
void destroyTree(Quadtree *restrict tree) {
  if (tree == NULL)
    return;
  if (tree->children != NULL) {
    cilk_spawn destroyTree(tree->children + 0);
    cilk_spawn destroyTree(tree->children + 1);
    cilk_spawn destroyTree(tree->children + 2);
    destroyTree(tree->children + 3);
    cilk_sync;
    free(tree->children);
  }
  free(tree->lines);
  // 如果只有一个结点
  if (tree->depth == 0)
    free(tree);
}
```

## 并行化使用四叉树检测线线碰撞

这里有三处并行化操作：

1. 检查当前树节点中的线段之间的碰撞，我们使用的`cilk_for`并行化外层函数
2. 递归检查子节点时，我们采用与销毁树的操作时一样的处理，将函数调用改成函数生成`cilk_spawn`。
3. 向上查找当前节点与其父节点们线段的碰撞情况时，使用`cilk_for`并行第二层循环。

<aside> 💡 这里不能将第一层循环也是用clik_for并行化，因为第一层循环中的parent变量在其子循环中都要用到，如果并行化就会存在变量的访问冲突问题，因此为了避免这种情况，我们只将中间层循环并行化。

</aside>

```c
// 对树里的结点进行碰撞检测
void detectCollision(Quadtree *restrict tree,
                     IntersectionEventList *restrict intersectionList) {
  assert(tree != NULL);

  Line *l1 = NULL;
  Line *l2 = NULL;

  uint16_t d, i, j;

  // 这里检查的是那些在矩形边缘不知道放在哪里的那些线段
  // 如果没有字结点 那么检查的就是当前结点中的线段的相交情况
  cilk_for(uint16_t i = 0; i < tree->num_lines; i++) {
    l1 = tree->lines[i];
    for (j = i + 1; j < tree->num_lines; j++) {
      l2 = tree->lines[j];
      registerCollision(l1, l2, intersectionList);
    }
  }

  // 检查子结点
  if (tree->children != NULL) {
    cilk_spawn detectCollision(tree->children + 0, intersectionList);
    cilk_spawn detectCollision(tree->children + 1, intersectionList);
    cilk_spawn detectCollision(tree->children + 2, intersectionList);
    detectCollision(tree->children + 3, intersectionList);
    cilk_sync;
  }

  // 向上查找
  // 判断当前结点中的线段与其所有的父节点中的线段是否有碰撞的可能
  // 也就是检查结点边缘的线段与内部结点线段是否能相交
  Quadtree *parent = tree;
  for (d = 0; d < tree->depth; d++) {
    parent = parent->parent;
    if (parent == NULL)
      return;
    cilk_for(uint16_t i = 0; i < tree->num_lines; i++) {
      l1 = tree->lines[i];
      for (j = 0; j < parent->num_lines; j++) {
        l2 = parent->lines[j];
        registerCollision(l1, l2, intersectionList);
      }
    }
  }
}
```

### 解决并发存在的冲突

上述对线段碰撞检测的并行优化过程中，当前函数确实不存在竞争问题，但是对于`registerCollision` 这个函数中是有冲突的，这一点使用opencilk提供的**`Cilksan`** 也无法检测到，很奇怪。

registerCollision的逻辑是检测传入的两条线段是否相交，如果相交，则生成一个碰撞节点，然后加入到碰撞节点的链表中，问题就出在这个加入碰撞链表的这个过程，因为这个链表是全局唯一的，我们传入的是链表指针，因此必然会存在竞争问题：两个线程同时插入一个节点（在其中一个插入未完成时另一个操作开始了，这样也可以看作是同时，造成的后果是一致的），就会导致先插入的节点丢失，导致出现错误。

找到了问题的源头，我们只需要在链表延长时加入一个互斥锁即可，这里使用的是 POSIX 线程库中用于实现互斥锁的数据类型`pthread_mutex_t` 。

具体源码如下：

```c
// 初始化锁
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void IntersectionEventList_appendNode(
    IntersectionEventList* intersectionEventList, Line* l1, Line* l2,
    IntersectionType intersectionType) {
  assert(compareLines(l1, l2) < 0);

  IntersectionEventNode* newNode = malloc(sizeof(IntersectionEventNode));
  if (newNode == NULL) {
    return;
  }

  newNode->l1 = l1;
  newNode->l2 = l2;
  newNode->intersectionType = intersectionType;
  newNode->next = NULL;

	// 获取锁
  pthread_mutex_lock(&mutex);
  if (intersectionEventList->head == NULL) {
    intersectionEventList->head = newNode;
  } else {
    intersectionEventList->tail->next = newNode;
  }
  intersectionEventList->tail = newNode;
  intersectionEventList->size++;
  // 释放锁
  pthread_mutex_unlock(&mutex);
}
```

## 性能提升情况

<aside> ‼️ 同样的，为了更好的对比，我们把程序的运行结果放到了实验报告的最后。

</aside>

<aside> 📝 以下实验结果均使用**默认的核心数8**、树的最大深度为**4**、每个结点最多的线段条数为**32**

</aside>

### 1000次迭代的情况

| **输入文件**                              | **执行时间（未优化）** | **执行时间（四叉树）** | 执行时间（并行化） | **线-墙碰撞次数** | **线-线碰撞次数** | **性能提升倍数（四叉树）** | 性能提升倍数（并行化） |
| ----------------------------------------- | ---------------------- | ---------------------- | ------------------ | ----------------- | ----------------- | -------------------------- | ---------------------- |
| **[mit.in](http://mit.in)**               | 10.43530 s             | 3.025782 s             | 0.739772s          | 170               | 2097              | **3.5**                    | **14**                 |
| **[beaver.in](http://beaver.in)**         | 1.594542 s             | 0.376237 s             | 0.165542s          | 7                 | 758               | **4.2**                    | **9**                  |
| **[box.in](http://box.in)**               | 2.400115 s             | 0.726586s              | 0.265180s          | 1379              | 36965             | **3.3**                    | **9**                  |
| **apple.in_old**                          | 4.319744 s             | 3.406659s              | 0.845595s          | 655               | 18718             | **1.3**                    | **5**                  |
| **sin_wave.in**                           | 18.564519 s            | 1.832190s              | 0.694283s          | 504               | 280083            | **10**                     | **26**                 |
| **[koch.in](http://koch.in)**             | 254.86879s             | 4.874691s              | 1.270284s          | 1088              | 5256              | **133**                    | **200**                |
| **apple.in_new**                          | 4.516861s              | 3.446063s              | 0.838880s          | 631               | 19729             | **1.3**                    | **5**                  |
| **[explosion.in](http://explosion.in)**   | 5.443508s              | 1.763039s              | 0.464102s          | 206               | 16837             | **3**                      | **11**                 |
| **[smalllines.in](http://smalllines.in)** | 4.489867s              | 1.461990s              | 0.430194s          | 5837              | 77802             | **3**                      | **10**                 |

### 4000次迭代情况

| **输入文件**                              | **执行时间（未优化）** | **执行时间（四叉树）** | 执行时间（并行化） | **线-墙碰撞次数** | **线-线碰撞次数** | **性能提升倍数（四叉树）** | 性能提升倍数（并行化） |
| ----------------------------------------- | ---------------------- | ---------------------- | ------------------ | ----------------- | ----------------- | -------------------------- | ---------------------- |
| **[mit.in](http://mit.in)**               | 39.266656s             | 8.113286s              | 2.028731s          | 1262              | 19806             | **4.8**                    | **20**                 |
| **[beaver.in](http://beaver.in)**         | 5.542460s              | 1.098662s              | 0.536846s          | 219               | 1798              | **5**                      | **10**                 |
| **[box.in](http://box.in)**               | 10.233927s             | 2.740106s              | 0.909408s          | 6239              | 101037            | **3.7**                    | **11**                 |
| **apple.in_old**                          | 18.572576s             | 12.43560s              | 3.003105s          | 3116              | 103117            | **1.5**                    | **6**                  |
| **sin_wave.in**                           | 77.297147s             | 7.171883s              | 2.276772s          | 1777              | 480244            | **10.8**                   | **33**                 |
| **[koch.in](http://koch.in)**             | 1030.7703s             | 18.76305s              | 5.843016s          | 9718              | 37592             | **55**                     | **176**                |
| **apple.in_new**                          | 19.098123s             | 11.93500s              | 2.960612s          | 2877              | 100951            | **1.6**                    | **6**                  |
| **[explosion.in](http://explosion.in)**   | 21.930666s             | 5.237843s              | 1.399301s          | 1310              | 42918             | **4.2**                    | **15**                 |
| **[smalllines.in](http://smalllines.in)** | 18.320586s             | 6.371052s              | 1.788540s          | 23895             | 338592            | **2.9**                    | **10**                 |

加入并行化性能再一次得到了明显提升。

# 总结

第一次接触四叉树的概念，查阅了很多资料，对lldb（gdb）又更熟悉了。。。

很享受性能提升的瞬间，虽然还有很多可以优化的点，因为某些原因并没有在测试版做完，但是希望在最终版可以让这个屏保程序运行的更加“极致“。

再一次认识到了软件性能提升的重要性。

