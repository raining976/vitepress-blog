# 实验目标

<aside>
✏️ 该部分介绍该实验的整体目标以及部分细节。

</aside>

### 实验的整体介绍

本实验初试代码实现了一个关于**二进制字符串的任意大小的子串左旋（右旋）任意位数的问题。**

实验的整体要求就是在现有的约束下，从任意角度改进原代码，使得程序的执行性能更快，越快越好。

### 几个约束条件

- 不能使用多线程编程。
- 标准C，不能使用内联汇编指令。
- 不能使用编译器内部函数或内部库达到实验要求的相同效果。

### 改进角度的提示与分析

假设目标子串是ab，我们已经可以通过自带函数获取子串ab，目标是得到其旋转后的串ba。

1. 用临时变量存储a，将b整体向左移动a的长度的距离，再将a拼接到b的后面。
    1. tmp空间过大时会影响缓存性能
2. 循环左移，跳跃移动距离，直接将bit位移动到目标位置。
    1. 内存访问被分散了（跳跃访问），不利于缓存
3. 翻转bit串，`(a'b')'=ba` (假设‘操作就是反转操作)。
    1. 理论上占用空间最小，并且对缓存友好。
    2. 同样存在进一步优化的可能。

针对实验讲义中的提示信息，我们分别在测试版和最终版采用了第二种和第三种优化思路，从两种不同的角度分别对程序进行了优化。

### 初步的安排以及分工

短短两周我们组从原来的四人组变为了双人组，所以分工情况就变得更加直接了，几乎都是由我们两人讨论、协商，并在同一台机器上编写的代码，所以分工相对不分散了。

最初的优化思路是直接采用最优化的按照字节反转bit串的角度，因为最后出现了当时没有解决的bug导致程序出现了正确性的问题，所以就先编写了从第二个角度考虑循环移位的改进，此改进角度也是在原来程序的思路上作出的优化，最终版的代码中我们解决了最开始的正确性的bug，并且也取得了比较理想了性能提升的效果。

### 各个过程的耗时

因为在实验项目初期我们各自进行了详细的优化分析，在做测试版优化的时候的优化方案已经达到了最终版的性能要求，所以整体进度比较快，后续的主要时间消耗在写实验进度报告上了。

- 分析源码：一晚上，3小时左右。
- 小组会议：一次，共两小时
- 编码优化：两个下午，6小时左右
- 测试修改bug：一晚上，3小时左右。

# 实验源码分析

## 分析实验的测试命令

```
usage: ./everybit
	 -s Run a sample small (0.01s) rotation operation
	 -m Run a sample medium (0.1s) rotation operation
	 -l Run a sample large (1s) rotation operation
	    (note: the provided -[s/m/l] options only test performance and NOT correctness.)
	 -t tests/default	Run alltests in the testfile tests/default
	 -n 1 -t tests/default	Run test 1 in the testfile tests/default
```

其中`-s/-m/-l` 只检测程序性能而不检测正确性。

`-t` 后指定测试文件的路径就可以测试其中的所有测试用例，用于检测程序正确性

`-n 1 -t`+测试文件路径可以运行目标文件中的编号为1的那个样例。

## 分析程序中的关键函数

### bit串的存储结构

```c
struct bitarray {
  size_t bit_sz;
  char* buf;
};
```

bitarray是一个自定义的结构体，其中`bit_sz` 是bit串中位的个数，`buf` 是一个**有符号char类型**的数据，显然存储bit串的单位是char，也就是按字节存储的，因此后续的优化思路也要从其存储组织结构出发思考优化的方向。

### 获取某一个bit在字节中的掩码

```c
static char bitmask (const size_t bit_index)
{
  return 1 << (bit_index % 8);
}
```

这里的`bit_index%8` 指的是bit在一个byte中的索引，最低位索引为0。

因此该函数的作用是获取一个只有`bit_index%8` 位置为1的一个byte，也就是关于这一位的byte的“掩码”。

### 获取bit串的特定位

```c
bool bitarray_get (const bitarray_t* const bitarray, const size_t bit_index)
{
		return (bitarray->buf[bit_index / 8] & bitmask (bit_index)) ? true : false;
}
```

该函数使用了上述的`bitmask()` 函数，获取到掩码后目标byte按位与后判断结果是否为0，如果为0，则目标位就是0（false），否则就是1（true）。

c语言中`stdbool.h` 标准bool库使用类似如下的宏定义实现的bool类型，因此这里使用了bool来返回得到的bit。

```c
#define bool _Bool
#define true 1
#define false 0
```

### 设置bit串某一位

```c
void bitarray_set (bitarray_t* const bitarray,const size_t bit_index,const bool value)
{
	bitarray->buf[bit_index / 8] =
    (bitarray->buf[bit_index / 8] & ~bitmask (bit_index)) |
    (value ? bitmask (bit_index) : 0);
}
```

这个函数实现思路很直接，先用mask取反将目标位置0，然后根据对value（新的bit）的判断按位或上mask或0就能实现对bit串中某一位的修改。

## 初始性能

编译最初的源码后，在下面机器配置上跑的情况如下：

- `-s`：13tiers，用时0.007496s
- `-m`：16tiers，用时0.051608s
- `-l`：19tiers，用时0.851679s

```
 Hardware Overview:
 
      Model Name: MacBook Air
      Model Identifier: MacBookAir10,1
      Model Number: MGN63CH/A
      Chip: Apple M1
      Total Number of Cores: 8 (4 performance and 4 efficiency)
      Memory: 8 GB
      System Firmware Version: 10151.81.1
      OS Loader Version: 10151.81.1
```

# 改进思路

## 通用优化点

我们观察到`bitmask` 函数的操作是得到某个bit在其字节中的偏移位置的掩码，这个结果是可以提前计算的，于是使用了静态数组提前保存结果，从而省去了计算过程。

```c
static char bitmask (const size_t bit_index)
{
  static const unsigned char mask[8] = { 1,2,4,8,16,32,64,128 };
  return mask[bit_index % 8];
}
```

## 思路1:循环移位

[project1 write up-张润宁](https://www.notion.so/project1-write-up-e6dca9f81c454421b52bb960a2aebd2e?pvs=21) 

[**测试版](https://www.notion.so/project1-write-up-e6dca9f81c454421b52bb960a2aebd2e?pvs=21)的个人writeup这部分讲的已经非常详细了。这里仅仅做个大概介绍。**

测试版的改进思路是在原有代码的基础上作出的改进，原有代码是一个一位的循环移位，旋转几次就每一位循环几次，效率很低；改进思路是不再进行一位一位的移动，而是通过计算直接将该位移动到目标位置，只需要计算出当前位和要移动到的位置，只需要一个固定大小的中间变量存储即可。

需要注意的是旋转次数会被子串长度整除的情况，这里具体的处理过程在测试版的个人writeup作出了详细的解释。不再赘述，本报告主要介绍整体过程以及对最终版的改进思路。

这里附上测试版的核心函数的完整代码：

```c
/**
 * @brief 循环移位
 * 
 * @param bitarray bit串
 * @param bit_offset 子串起始索引
 * @param bit_length 子串长度
 * @param right_count 右旋位数
 */
static void bitarray_rotate_cyclic (bitarray_t* const bitarray, const size_t bit_offset, const size_t bit_length, const size_t right_count)
{
  if(bit_length == 0) return;

  assert (bit_offset + bit_length <= bitarray->bit_sz);

  size_t cycle, cycle_nums = 1; // cycle_nums 一共要循环几次 是外层循环的总数 初始化为1
  size_t step, period = bit_length; // period 每次循环一共跳跃多少步 是内循环数 初始化为1
  // 如果没有被整除 显然只需要循环一次 这次循环要跳跃bit_length步，才能保证所有的bit都被正确移动了

  // 如果长度可以被需要移动的位数所整除 
  if(bit_length % right_count == 0) {
    period = bit_length / right_count;
    cycle_nums = bit_length / period;
  }

  // 不要忽略“反向整除” right_count 很大时，另一小部分可能也会被整除
  if(bit_length % (bit_length - right_count) == 0) {
    period = bit_length / (bit_length - right_count);
    cycle_nums = bit_length / period;
  }

  bool prev, next; // 前一个、后一个位置的bit值
  size_t p = bit_offset; // 初始化前一个位置索引
  size_t n = bit_offset + modulo (p + right_count - bit_offset, bit_length); // 循环跳跃 模运算是为了到达子串最后时循环回来

  for(cycle = 0; cycle < cycle_nums; cycle++) {
    prev = bitarray_get (bitarray, p);
    next = bitarray_get (bitarray, n);

    for(step = 0; step < period; step++) {
      bitarray_set (bitarray, n, prev); // 前一个位置替换后一个位置 右循环
      if(step < period - 1) { // 如果不是最后一个 就更新p n索引
        p = n;
        prev = next;
        n = bit_offset + modulo (p + right_count - bit_offset, bit_length); // 这里的p已经被更新了 实际是当前的n
        next = bitarray_get (bitarray, n);
      }
    }

    // 能被整除时 这里就需要手动进入下一轮的循环 否则就会一直陷入对一部分的bit的修改
    p++;
    n = bit_offset + modulo (p + right_count - bit_offset, bit_length);
  }
}
```

## 思路2:三次翻转操作

翻转操作最简单的实现是以bit为单位将目标子串依次进行翻转，但是显然当bit串**非常大**的时候，这种一位一位进行翻转的效率仍然是很低的，所以我们直接在此思路的基础上进一步优化来作为最终版的优化方案，那就是**以字节为单位进行翻转操作**，这里涉及到字节本身的翻转操作，因此第一个问题是如何对字节进行高效的翻转操作。

### 对单个字节进行整体翻转

传统的思路是对一个字节的8位进行遍历，4次循环操作即可翻转整个字节，但是随着输入数据长度的增加，显然这个操作在整体的效率中影响很大，因此我们直接考虑优化此“子过程”。

结合理论课上的一些优化思路的启发，我们注意到，每个char类型的数据占8bit，因此所有无符号char类型的数据共有$2^8$个，数据范围是$[0,2^8-1]$，有限个数据，并且对于每个字节的反转字节我们是提前可知的，因此就考虑到了利用静态数组预先存储好每个unsigned char类型的对应的反转字节是多少，这样在需要用到反转字节的时候直接取地址即可，理论上可以有效提高性能并且该方法缓存友好。至于无符号到有符号的转换可以直接强转，这并不会带来很大的性能开销。

这部分的代码优化如下：

```c

/**
 * @brief 获取目标字节的反转字节
 *
 * @param byte 反转字节的源字节
 * @return unsigned char
 */
unsigned char get_reverse_byte (unsigned char byte)
{
static const unsigned char reverse_byte_map[256] = {
0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

  return (unsigned char)reverse_byte_map[byte];
}
```

### 核心思路

有了上述辅助函数的优化，针对整体按照字节反转，我们就可以只关注整体算法了。

实验手册的提示中提到了，假如目标子串是ab，最终目标是得到ba，那么我们可以进行一个`(a'b')'` 的操作就可以得到目标串，因此实际上这个过程分为三部分

1. 反转`a`
2. 反转`b`
3. 反转`a’b’`(加‘这里代表反转后的串)

代码如下：

```c
/**
 * @brief 反转一个bit串的任意子串
 *
 * @param bitarray bit串
 * @param bit_offset 子串起始索引
 * @param bit_length 子串长度
 * @param right_count 子串两部分 右侧长度
 */
static void bitarray_rotate_reverse (bitarray_t* const bitarray, const size_t bit_offset, const size_t bit_length, const size_t right_count)
{
  assert (bit_offset + bit_length <= bitarray->bit_sz); // 防止越界
  if(bitarray->bit_sz < 2) return;

  // 反转第一部分
  subarray_rotate_reverse (bitarray, bit_offset, right_count);
  // 反转第二部分
  subarray_rotate_reverse (bitarray, bit_offset + right_count, bit_length - right_count);
  // 整体反转
  subarray_rotate_reverse (bitarray, bit_offset, bit_length);
}
```

因此算法核心在于：**如何对一个给定的子串以字节为单位进行翻转的问题**

接下来我们着重讨论这个问题

### 前置分析

对于一个给定的bit子串，因为是以字节为单位进行翻转操作的，因此很容易想到任意取到的bit串可能不会刚刚好是buf数组中的某个字节的开始或结束，也就是说**待翻转的部分总会有一些bit不正好在整字节中。**考虑到这个问题，我们采取的思路是，将包含待翻转子串的那些字节全部翻转，一般情况下待翻转的那一部分必然也会出现不对称的情况，也就是说距离正确的翻转偏移了一部分，因此需要进行整体移位操作，而且由于这段子串的开始和结束字节并不是正好的，所以我们在翻转后还需要考虑还原原来的头部和尾部字节，并且将正确的翻转赋值给他们。

### 具体算法过程

有了上述的分析，我们仍然通过举一个例子的方式来详细描述这个算法过程：

一些变量的说明:

- `bit_offset`:子串bit的起始索引（相对于位的索引）
- `bit_end_index`:子串尾部bit的索引，这个可以通过$bit\_offset+bit\_length-1$计算得来
- `bit_length`：子串长度
- `byte_start_index`:开始字节索引
- `byte_end_index`:结束字节索引

图示如下：其中橙色框中表示我们需要翻转的目标子串，绿色框表示的是实际第一步按照字节翻转的部分。

具体过程如下：

1. 从`byte_start_index` 开始遍历，到中点字节，每次循环将首尾字节翻转并交换。
    
    其中`size_t mid_index = start_byte_index + (end_byte_index - start_byte_index) / 2;` 的操作是防止索引很大时相加溢出。
    
    ```c
    /**
     * @brief 以字节为单位翻转目标索引区间内的所有字节
     *
     * @param bitarray 原bit串
     * @param start_byte_index 开始索引
     * @param end_byte_index 结束索引
     */
    void bitarray_reverse_byByte (bitarray_t* const bitarray, const size_t start_byte_index, const size_t end_byte_index)
    {
      // 中点位置索引
      size_t mid_index = start_byte_index + (end_byte_index - start_byte_index) / 2;
      size_t temp_index;
      unsigned char temp;
      // 先不考虑多出来的bit 直接以字节为单位翻转所有待翻转区间内的所有字节
      for(size_t i = start_byte_index; i <= mid_index; i++) {
        // i-a  j = b-(i-a)
        temp_index = end_byte_index + start_byte_index - i; // 对称位置的索引
        temp = get_reverse_byte (bitarray_get_byte (bitarray, temp_index));
        bitarray_set_byte (bitarray, temp_index, get_reverse_byte (bitarray_get_byte (bitarray, i)));
        bitarray_set_byte (bitarray, i, temp);
      }
    }
    ```
    
2. 计算偏移量：上述分析在一般情况下这种翻转会bit串翻转后整体偏移，因此下一步操作要将目标子串整体移位到正确的位置，在此之前要计算偏移多少位的问题。
    
    此时就需要计算两个比较重要的变量，也就是`bit_offset` 相对于第一个字节的末尾bit偏移了多少，`bit_end_index` 相对于最后一个字节偏移了多少，这一步的计算过程不在赘述，代码如下：
    
    ```c
     // 计算偏移量 （start_bit那里多了偏移了多少，end_bit偏移了多少）
     // 1~8
     size_t shift_start_bit = modulo (8 - bit_offset, 8);
     size_t shift_end_bit = (end_bit_index + 1) % 8;
     
      if(shift_end_bit == 0) shift_end_bit += 8;
      if(shift_start_bit == 0) shift_start_bit += 8;
    ```
    
    <aside>
    💡 这里后面对偏移量为0进行了判断并且如果为0就进行+=8的操作，这是考虑了对于bit的开始和结束刚好取到字节的开始和末尾的情况。如果只有一方是正好的情况，此时我们认为便宜了了一整个字节，这与后续的判断和计算有关。
    
    </aside>
    
3. 整体移位：
    
    因为此时移位的位数一定不等于字节数，如果我们以bit为单位进行移位的话此时的性能显然会成为瓶颈（因为翻转是以字节为单位的，此时如果按bit移位势必会拉低整体性能）所以我们在这里的移位也要考虑通过字节操作进行移位。
    
    基本思路就是遍历整个需要移动的字节，向后移动就倒序遍历，向前移动就正序遍历，每次取当前字节和下一个字节，根据需要移动的位数，将当前字节调整为移动后的字节的数值，具体操作就是**将翻转后的字节翻回来后移位，再按位与，然后再翻转**，即可得到移动后的字节数值。至于循环末尾的字节，因为末尾字节的下一个字节是无需改变的，也不能改变，因此我们就只需要翻转后左移或右移固定位数再翻转回去即可。
    
    ```c
     unsigned char a, b, reverse;
      ssize_t shift = shift_end_bit - shift_start_bit; // 这个差值必须是有符号数
      // 处理偏移
      if(shift > 0) { // end的偏移要大于start的偏移 此时需要整体将bit向着end的方向移动
        for(size_t i = end_byte_index; i >= start_byte_index; i--) {
          if(i == start_byte_index) {
            reverse = get_reverse_byte (bitarray_get_byte (bitarray, i)) >> shift;
            bitarray_set_byte (bitarray, i, get_reverse_byte (reverse));
            break;
          } else {
            a = get_reverse_byte (bitarray_get_byte (bitarray, i)) >> shift;
            b = get_reverse_byte (bitarray_get_byte (bitarray, i - 1)) << (8 - shift);
            bitarray_set_byte (bitarray, i, get_reverse_byte (a | b));
          }
        }
      } else if(shift < 0) {
        for(size_t i = start_byte_index; i <= end_byte_index; i++) {
          if(i == end_byte_index) {
            reverse = get_reverse_byte (bitarray_get_byte (bitarray, i)) << (-shift);
            bitarray_set_byte (bitarray, i, get_reverse_byte (reverse));
            break;
          } else {
            a = get_reverse_byte (bitarray_get_byte (bitarray, i)) << (-shift);
            b = get_reverse_byte (bitarray_get_byte (bitarray, i + 1)) >> (8 + shift);
            bitarray_set_byte (bitarray, i, get_reverse_byte (a | b));
          }
        }
      }
    ```
    
4. 将偏移的位置重新翻转回去之后，此时橙色框的子串已经正确翻转并且结果正确了，剩下要处理的就是由于我们进行**整个字节的反转以及整体移位，导致开始字节和末尾字节的不需要翻转的部分与原来不一致了。**
    
    因此最后一步操作就是将开始字节和末尾字节恢复原状，考虑到这个需求，因此在第一步翻转之前我们就要保留开始字节和末尾字节，防止丢失。
    
    与第三步子过程一致，也是通过移位和按位与将原来的bit还原，具体不在赘述。
    
    ```c
    unsigned char start_right = (unsigned char)(first_byte_reverse >> shift_start_bit) << shift_start_bit;
      unsigned char start_left = (unsigned char)(get_reverse_byte ((unsigned char)bitarray_get_byte (bitarray, start_byte_index)) << (8 - shift_start_bit))  >> (8 - shift_start_bit);
      bitarray_set_byte (bitarray, start_byte_index, get_reverse_byte (start_right | start_left));
    
      // end端同理
      unsigned char end_left = (unsigned char)(last_byte_reverse << shift_end_bit) >> shift_end_bit;
      unsigned char end_right = (unsigned char)(get_reverse_byte ((unsigned char)bitarray_get_byte (bitarray, end_byte_index)) >> (8 - shift_end_bit)) << (8 - shift_end_bit);
      bitarray_set_byte (bitarray, end_byte_index, get_reverse_byte (end_right | end_left));
    ```
    



### 性能提升情况

- `-s`:32个tiers
- `-m`:38个tiers
- `-l`:42个tiers（**达到最终版的性能要求38tiers**）

以-l为例，初始情况下19tiers，用时0.851679s，而最终版本19tier的用时为0.000027s

直观从时间角度估计性能提升了近**31500**倍，从数据大小上来看，-l在1s的限制下最长样例为218MB，而初始最长样例为3KB，从这个角度看性能提升了**72000**多倍！


# 实验总结

总体的实验收获很大，无论是从团队合作、分工统筹，以及编码和调试能力上都有了质的飞跃！

对软件性能优化的认识更进一步，更直观的感受到了软件性能优化对工程、系统优化的重要性，也希望能在以后的课程和实验上收获更多！