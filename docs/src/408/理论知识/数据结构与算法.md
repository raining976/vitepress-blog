---
description: 数据结构与算法的理论知识 
---
# 数据结构与算法（王道）

## 数据结构和算法的定义

### 什么是数据结构

#### 一些基本概念

- 数据：描述客观事物的字符，能够被计算机所处理的集合。
- 数据元素：数据的基本单位，通常作为一个整体考虑。
  - 数据项：数据元素包含很多数据项，数据项是最小的不可分割的单位
- 数据对象：相同性质的数据元素的集合
- 数据类型：值的集合和定义在该集合上一组操作的总称
  1. 原子类型：值不可再分
  2. 结构类型：值可以再分解
  3. 抽象数据类型：一个数学模型定义在该数学模型的一组操作。
- 数据结构：相互之间存在一种或多种特定关系的数据元素的集合。

  数据结构包含三部分内容：逻辑结构、存储结构、运算。

#### 数据结构三要素

1. 逻辑结构：数据元素之间的关系，与数据存储无关
2. 存储结构：数据结构在计算机中的表示
3. 数据运算：施加在数据上的运算包括运算的定义和实现。

### 什么是算法

#### 概念

算法是对特定问题求解步骤的描述。

五个特性

1. 有穷性：步骤有限，有限时间内完成
2. 确定性：每个步骤含义明确，相同输入得到相同的输出
3. 可行性：算法中描述的操作都可以用已经实现的基本运算执行有限次实现
4. 输入：0个或多个输入
5. 输出：一个或多个输出

#### 算法度量

1. 时间复杂度
2. 空间复杂度

## 线性表

### 线性表的定义和基本操作

#### 线性表的定义

具有<u>相同</u>数据类型的n数据的<u>有限</u>序列

特点：

- 元素个数有限
- 元素具有逻辑上的顺序性，有先后次序
- 表中元素都是数据元素，每个元素都是单个元素
- 元素数据类型相同，即每个元素占用相同的空间大小
- 元素具有抽象性，仅讨论元素之间的逻辑关系，而不是值

注意线性表定义的是逻辑关系

#### 基本操作

- `InitList(&L)`：初始化空表
- `Length(L)`：求表长
- `LocateElem(L,e)`：按值查表
- `GetElem(L,i)`：按照位置查表
- `ListInsert(&L, i, e)`：插入操作，在第i个位置插入元素e（i从1开始计数）
- `ListDelete(&L, i, &e)`：删除操作，删除表中第i个元素，用e存储值（i从1开始计数）
- `PrintList(L)`：按照先后顺序输出表中所有值
- `Empty(L)`：判断是否为空
- `DestroyList(&L)`：销毁线性表，并释放线性表所占用的空间。

> [!note]
>
> 插入与删除中的i都是从1开始计数的，那么插入的i的范围就是从1到length+1的范围，length+1说明插入到最后一个元素之后。而删除时i的有效范围是从1到length

### 线性表的顺序表示

这里的“顺序”描述的是存储逻辑。

#### 顺序表的定义

顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

顺序表的空间既可以静态分配（固定大小的栈空间）可以动态分配（用户可以重新分配的堆空间）

##### 优点

1. 可以随机访问，O(1)时间的查找序号元素
2. 存储密度高，不会存储额外的信息，只有值

##### 缺点

1. 插入和删除需要移动大量元素，插入平均移动$\frac{n}{2}$个元素,删除平局移动$\frac{n-1}{2}$
2. 连续空间分配的时候不够灵活

#### 顺序表基本操作的实现

##### 初始化

静态分配空间

```C
void InitList(SqList &L){
	L.length = 0;
}
```

动态分配空间

```C
void InitList(SqList &L){
  L.data = (ElemType *)malloc(MaxSize*sizeof(ElemType));
  L.length = 0;
  L.MaxSize = InitSize;
}
```

##### 插入操作

```C
bool ListInsert(SqList &L, int i, ElemType e){
  if(i < 1 || i > L.length + 1){ // 注意插入时位置i的范围是1-length+1
    return false;
  }
  if(L.length >= MaxSize){
    return false;
  }
  for(int j = L.length; j >= i; j--){
    L.data[j] = L.data[j-1];  // i位置以及之后的元素后移一个位置
  }
  L.data[i-1] = e;
  L.length ++;
  return true;
}
```

最好情况：表尾插入，时间复杂度O(1)

最坏情况：表头插入，时间复杂度O(n)

平均情况：假设$p_i$是在第i个位置插入的概率，$p_i=1/(1+n)$，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：

$\sum^{n+1}_{i=1}p_i(n-i+1)=\sum^{n+1}_{i=1}\frac{1}{n+1}(n-i+1)=\frac{1}{n+1}\sum^{n+1}_{i=1}=\frac{1}{n+1}\frac{n(n+1)}{2}=\frac{n}{2}$

##### 删除操作

```C
bool ListDelete(SqList &L, int i, ElemType &e){
	if(i < 1 || i > L.length) return false;
  e = L.data[i-1];
  for(int j = i; j < L.length; j++){
  	L.data[j-1] = L.data[j];  // 删除位置之后的元素前移一位
  }
  L.length --;
  return true;
}
```

最好情况：删除 表尾元素，时间复杂度O(1)

最坏 情况：删除表头元素，时间复杂度O(n)

平均情况：假设$p_i(p_i=1/n)$是删除第i个结点的概率，则在长度为n的线性表中国呢删除一个结点时，所需移动的结点平均次数为:

$\sum^{n}_{i=1}p_i(n-i)=\frac{1}{n}\sum^{n}_{i=1}(n-i)=\frac{1}{n}\frac{n(n-1)}{2}=\frac{n-1}{2}$

##### 按值查找

```C
int LocateElem(SqList L, ElemType e){
  int i;
  for(i = 0; i < L.length; i++){
    if(L.data[i] == e){
      return i + 1;  // 位次，从1开始
    }
  }
  return 0; // 没找到
}
```

平均情况：

$\sum^{n}_{i=1}p_i i=\sum^{n}_{i=1}\frac{1}{n}i=\frac{1}{n}\frac{n(n+1)}{2}=\frac{n+1}{2}$

### 线性表的链表表示

#### 单链表

##### 链表定义

线性表的链式存储又称为单链表。结点中存储的数据以及指向下一个结点的指针。

单链表解决了顺序表需要使用大量空间的缺点，但是附加的指针域也降低空间的利用率。由于其存储是分散存储在空间中的，因此是非随机存储的存储结构，即不能直接找到链表中某个特定的结点，查找结点需要从头开始遍历。

两种表示方式：使用头结点和不使用头结点。

头结点中不存实际的数据，只是了为了实现方便。

1. 使用头结点：空表的头指针指向头结点，此时判断链表为空需要看头指针指向的头结点的指针域是不是空。
2. 不使用头结点：空表的头指针指向NULL

##### 单链表基本操作的实现

1. 初始化单链表

   - 带头结点

   ```C
   bool InitList(LinkList &L){
     L = (LNode*)malloc(sizeof(LNode));
     L->next = NULL;
     return true;
   }
   ```

   - 不带头结点

     ```C
     bool InitList(LinkList &L){
       L = NULL;
       return true;
     }
     ```

     

2. 求表长

   ```C
   int Length(LinkList L){
     int len = 0;
     LNode *p = L;
     while(p->next != NULL){
       p = p->next;
       len++;
     }
     return len;
   }
   ```

3. 按序号查找结点

   ```C
   LNode *GetElem(LinkList L, int i){
     LNode *p = L;
     int j = 0;
     while(p != NULL && j < i){
       p = p->next;
       j++;
     }
     return p;
   }
   ```

4. 按值查找结点

   ```C
   LNode *LocateElem(LinkList L, ElemType e){
     LNode *p = L->next;
     whiel(p != NULL && p->data != e){
       p = p->next;
     }
     return p;
   }
   ```

5. 插入结点操作

   ```C
   bool ListInsert(LinkList &L, int i, ElemType e){
   	LNode *p = L:
     int j = 0;
     while(p!=NULL && j < i - 1){
       p = p->next;
       j++;
     }
     if(p == NULL){
       return false;
     }
     LNode *s = (LNode *)malloc(sizeof(LNode));
     s->data = e;
     s->next = p->next;
     p->next = s;
     return true;
   }
   ```

   如果要求前插操作，可以用这个方法插入后，交换一下两个结点的值就行了。

6. 删除结点操作

   ```C
   bool ListDelete(LinkList &L, int i, ElemType &e){
     LNode *p = L;
     int j = 0;
     while(p != NULL && j < i - 1){
       p = p->next;
       j++;
     }
     if(p == NULL || p->next == NULL){ // i不合法
       return false;
     }
     LNode *q = p->next;
     e = q->data;
     p->next = q->next;
     free(q);
     return true;
   }
   ```

   删除结点`*p`可以用删除结点p的下一个结点，先把后继的值赋值给p，然后删除后继的结点。

7. 采用头插法建立单链表

   ```C
   LinkList List_HeadInsert(LinkList &L){
     LNode *s; int x;
     L = (LNode*)malloc(sizeof(LNode));
     L->next = NULL;
     scanf("%d", &x);
     while(x != 9999){
       s = (LNode *)malloc(sizeof(LNode));
       s->data = x;
       s->next = L->next;
       L->next = s;
       scanf("%d", &x);
     }
     return L;
   }
   ```

8. 采用尾插法建立单链表

   需要维护一个尾指针，指向最后一个结点

   ```C
   LinkList List_TailInsert(LinkList &L){
     int x;
     L = (LNode*)malloc(sizeof(LNode));
     LNode *s, *r = L;
     scanf("%d", &x);
     while(x != 9999){
   		s = (LNode*)malloc(sizeof(LNode));
       s->data = x;
       r->next = s;
       r = s;
       scanf("%d", &x);
     }
     r->next = NULL;
     return L;
   }
   ```

#### 双链表

- 方便访问结点前驱。
- 结点有两个指针域，prior和next，分别指向直接前驱和直接后驱

```C
typedef struct DNode{
  ElemType data;
  struct DNode *prior, *next;
}DNode, *DLinkList;
```

1. 双链表插入

   在p和c中间插入s(`p->c`=>`p->s->c`)，当前只拿到了p

   ```C
   s->next = p->next;
   p->next->prior = s;
   p->next = s;
   s->prior = p;
   ```

2. 双链表删除

   `p->q->c`=>`p->c`

   ```C
   p->next = q->next;
   q->next->prior = p;
   free(q)
   ```

   

#### 循环链表

1. 循环单链表

   最后一个结点指向头结点。

   循环单链表判空：<u>头结点的next是L</u>

   注意如果只有头指针，则在表尾插入需要O(n)

2. 循环双链表

   头结点的prior指向表尾，尾结点的next指向头结点

   循环双链表判空：<u>头结点的两个指针都是L</u>

#### 静态链表

连续空间存储，指针是相对的地址（数组中的索引）

```C
typedef struct{
  ElemType data;
  int next;
} SLinkList(MaxSize);
```

next == -1表示当前结点已经是最后一个结点了。

### 顺序表和链表的比较

1. 存取方式

   顺序表可以顺序存储，也可以随机存取；链表只能从表头依次存取。

2. 逻辑结构和物理结构

   顺序存储时，逻辑相邻的元素在物理结构上也相邻；链式就不一定相邻。

3. 查找、插入和删除操作

   按照值查找。无序时两者时间复杂度都为O(n)

   按照序号查找，顺序表O(1),链表O(n)

   插入删除顺序表需要移动元素，而链表只需要修改指针域

4. 空间分配

   顺序存储在静态存储的情况下，一旦存储空间装满就不能扩充；预先分配过大，会导致大量空间闲置。

   链式存储的结点空间只在需要时申请分配，操作灵活高效。但是由于链表每个结点都有指针域，因此存储密度不够大。

## 栈、队列和数组

### 栈

#### 栈的基本概念

##### 定义

栈是只允许在一端进行插入和删除操作的线性表。

##### 基本操作

- `InitStack(&S)`
- `StackEmpty(S)`
- `Push(&S, x)`
- `Pop(&S, &x)`
- `GetTop(S, &x)`
- `DestroyStack(&S)`

#### 栈的顺序存储结构

##### 实现

```C
typedef struct{
  Elemtype data[Maxsize];
  int top;
} SqStack;
```

初始时top的值决定了之后在进栈和出栈的操作顺序。

- top初始为-1：
  - 进栈：data[++top] = x;
  - 出栈：return data[top--]
  - 栈空：top == -1
  - 栈满：top == MaxSize-1
  - 栈长：top+1
- top初始为0：
  - 进栈：data[top++] = x
  - 出栈：return data[--top]
  - 栈空：top == 0
  - 栈满：top == MaxSize
  - 栈长：top

##### 基本操作(top初始-1为例

1. 初始化

   ```C
   void InitStack(SqStack &S){
     S.top = -1;
   }
   ```

2. 判断空

   ```C
   bool StackEmpty(SqStack &S){
     return S.top == -1;
   }
   ```

3. 进栈

   ```C
   bool Push(SqStack &S, ElemType x){
     if(S.top == MaxSize - 1) return false;
     S.data[++S.top] = x;
     return true;
   }
   ```

   

4. 出栈

   ```C
   bool Pop(SqStack &S, ElemType &x){
     if(S.top == -1) return false;
     x = S.data[top--];
     return true;
   }
   ```

5. 获取栈顶

   ```c
   bool GetTop(SqStack S, ElemType &x){
     if(S.top == -1) return false;
     x = S.data[S.top];
     return false;
   }
   ```

   

##### 共享栈

数组两头都可以作为栈底部。

### 队列

#### 基本概念

1. 定义

   操作受限的线性表，先进先出

2. 基本操作

   - initQueue
   - QueueEmpty
   - EnQueue
   - DeQueue
   - GetHead

#### 队列的顺序存储结构

##### 顺序存储

用数组存，维护两个指针：队头和队尾指针，队头指针front指向头元素，队尾指针rear指向队尾元素的下一个位置。（比较灵活）

空队列：front=rear=0

进队操作：队列不满时，先送值到队尾，再将队尾指针+1

出队草足：队不空，先取队头值，再将队头指针+1

满队列判定？rear==MaxSize，无法判定

##### 循环队列

取余实现循环

初始时：front=rear=0

队列长度：(rear+maxsize-front)%maxsize

队空用front==rear判断，如何判断队满？三种方式

1. 少用一个单元，队头指针在队尾指针的下一个位置作为队满的标志

   (rear+1)%maxsize == front

2. 维护一个size变量，进队和出队都修改这个值

3. 增设一个tag变量，进队设置为1，出队设置为0，front==rear时使用tag标记空还是满

##### 链表结构

带有尾指针的单链表。头指针指向队头结点，尾指针指向最后一个结点。

#### 受限的双端队列

允许在一端插入和删除，但在另一端只能插入的队列称为输出受限的双端队列

允许在一端插入和删除，但在另一端只能删除的队列称为输入受限的双端队列

### 栈和队列的应用

#### 栈-匹配括号

收到左括号，就入栈，收到右括号，就看看栈顶是不是能与这个右括号匹配，如果匹配就将栈顶弹出，否则报错。

最后栈为空，则匹配成功，否则失败。

#### 栈-求表达式

##### 中缀转后缀：

- 遇到操作数，直接加入后缀表达式

- 遇到括号，如果为左括号，入栈，若为右括号，则依次弹出栈中运算符，并加入后缀表达式，直到弹出左括号为止
- 遇到运算符：若优先级高于栈顶运算符（栈顶为左括号直接入栈），则直接入栈；若优先级低于栈顶运算符，则依次弹出所有优先级高于以及等于当前运算符的元素，并加入后缀表达式，之后将当前运算符入栈。

##### 求后缀表达式

扫描后缀表达式，如果是操作数，入栈，如果是运算符，则依次取出XY，执行`Y<op>X`，得到结果后将结果入栈。

#### 队列-层次遍历

利用队列实现树（图）的层次遍历

1. 根入队
2. 若队列空，结束；否则重复3
3. 队列中第一个结点出队，依次将其左右孩子入队（如果有的话），返回2

#### 队列-计算机系统的应用

- 解决主机与外部设备速度不匹配的问题
- 解决多用户引起的资源竞争

### 数组与特殊矩阵

#### 数组定义

由n个相同类型的元素组成的有序序列。

数组是线性表的推广，一个数组可以认为是一个线性表，二维数组可以视为是定长数组的线性表。

#### 存储结构

连续存储空间。

超过一维的数组也一样，比如二维：第一行、第二行、第三行这样顺序放进一段连续空间。

按照行优先就是如上所说，按照列优先就是第一列、第二列、第三列的顺序存储到一段连续空间。

#### 特殊矩阵的压缩存储

所谓的压缩是相同的元素只分配一个空间，对0元素不分配空间。

##### 对称矩阵

压缩的思路是将相同的元素存储到一维矩阵的同一个位置

比如如果只存下半个三角，那么存储顺序就是：（用下标表示元素）11、21、22、31、32、33。。。。

只需要算出来，元素ij，在整个数组中的位置就可以

前i-1行的元素数量是：$1+2+3+...+(i-1)=\frac{i*(i-1)}{2}$​

再加上第i行的前j-1个元素，那么ij的存储位置:$k=\frac{i(i-1)}{2}+j-1$

对于上三角的元素$k=\frac{j(j-1)}{2}+i-1$

##### 三角矩阵

分为上三角矩阵和下三角矩阵。下三角矩阵的上三角区域元素是一个常量；下三角的上三角区域元素是一个常量。

基本的逻辑就是压缩值相同的那部分，通过建立ij与存储数组下标的映射进行存储。

与对称矩阵思路一致。一维数组最后一个位置存0

##### 三对角矩阵

![image-20241014211651937](https://gitee.com/raining976/markdown-imgs/raw/master/img/image-20241014211651937.png)

### 串的模式匹配

子串的定位操作称为串的模式匹配。

##### 朴素的模式匹配

依次从待匹配的串的每一位*开始*，依次匹配子串的每一位，如果这次匹配失败，则从上次待匹配串开始的位置的下一位重新开始匹配。

时间复杂度为O(mn)

##### KMP算法

本质上，kmp实际上就是优化了待匹配串开始匹配位置的选择，朴素算法是每次都将开始匹配的位置+1，但仔细观察就会发现，实际上通过子串的匹配，我们可以*肉眼*观察出某些匹配是毫无意义的，也就是说从这些位置开始的匹配一定是失败的。所以可以直接跳过这部分的匹配，从而提高效率。

现在的关键问题：哪些可以跳过？怎么跳过？

##### 前缀、后缀、部分匹配值

在解决这两个问题之前，先介绍几个必要的概念

- 前缀：字符串从最左边字符开始的一个子串

- 后缀：字符串以最右边字符结束的一个子串

- 部分匹配值：前缀和后缀的最长相等的长度。

  举个例子：abacdaba，前后缀最长相等的部分aba，那么部分匹配值就是3

有了这个部分匹配值，我们很容易就能看出来，比如某一次匹配失败，我们就能通过已经匹配的子串的部分，来决定下次待匹配串的开始位置，比如abcac模式串上次匹配到了倒数第二个a，那么下次匹配，指向待匹配串的指针可以直接向前移动3个（上次是从第一个a开始的，下次可以跳过从b和c开始，而是直接从下一个a开始），而不是一个一个移动，从而跳过了大量操作。

这样的匹配过程，主串的开始指针不需要后退。

每次开始匹配的位置的增加量计算：`模式串上次匹配成功的索引-模式串上一个位置的部分匹配值`

每次失败找前一个元素的部分匹配值会不方便，所以可以将这个表后移动一位，也就是当前元素的位置存储的是上一个元素的匹配值，其中第一个位置是-1，这样就得到了`next`数组。

整体向右移动一位部分匹配值的表，最高位会溢出，但是不影响，因为它的含义是下一个元素匹配失败才会用得上，显然它是最后一个元素，没有下一个元素，所以合理。

代码中移动的实际上是模式串的指针，next[j]的含义是：当子串的第j个字符匹配失败时，将j跳转到next[j]的位置，与主串当前位置重新开始匹配。

##### 如何求next数组

现在的关键问题实际上是转为了如何求出next数组，只要求出来模式串的next数组，那么匹配算法实际上就和朴素的算法很像了，只需要在合适的时机换一下指针就可以了。
